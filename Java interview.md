# Java面试

## 面试热点

[TOC]

### 1.数据结构（程序 = 数据结构+算法）

#### 1.1、八大数据结构分类

常用的数据结构有：数组，栈，链表，队列，树，图，堆，散列表等

![](C:\Users\wzh\Desktop\Java interview\images\QQ图片20190517124705.jpg)

#### 1.2、数据结构原理：队列，堆栈，红黑树，哈希表，链表

#### 1.3、数据结构在Java中集合类型

数组：ArrayList，Vector

链表：LinkedList

二叉树：TreeSet,TreeMap

哈希表：HashSet,HashMap

#### 1.4、JDK1.7到JDK1.8的HashMap底层实现有什么不同，这些变化解决了什么问题

在JDK1.6，JDK1.7中，HashMap采用位桶+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。

JDK1.8中，HashMap采用位桶+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。

#### 1.5、hashmap线程是否安全，如何解决

不安全，使用ConcurrentHashMap

### 2.多线程

#### 2.1、实现多线程的方式

1. 继承Thread类
2. 实现Runnable接口
3. 实现Callable接口通过FutureTask包装器来创建Thread线程
4. 使用ExecutorService、Callable、Future实现有返回结果的多线程

#### 2.2、多线程的通信方式

1. 同步，多个线程通过synchronized关键字这种方式来实现线程间的通信
2. while轮询的方式
3. wait/notify机制
4. **管道通信**就是使用java.io.PipedInputStream 和 java.io.PipedOutputStream进行通信

#### 2.3、各种不同锁机制及差别

1. synchronized
2. ReentrantLock
3. Semaphore
4. AtomicInteger

#### 2.4、JUC包的常用API，如线程池，各种队列及作用

1、常用API：

- ConcurrentSkipListMap
- ConcurrentHashMap

2、线程池：

- newCachedThreadPool创建一个可缓存线程池程
- newFixedThreadPool 创建一个定长线程池
- newScheduledThreadPool 创建一个定长线程池
- newSingleThreadExecutor 创建一个单线程化的线程池

3、队列：

- ConcurrentLinkedQueue
- ConcurrentLinkedDeque
- DelayQueue
- ArrayBlockingQueue
- LinkedBlockingQueue
- LinkedBlockingDeque
- PriorityBlockingQueue
- SynchronousQueue
- LinkedTransferQueue
- <https://www.jianshu.com/p/21f73cd8e453>

#### 2.5、线程安全怎么控制

### 3.JVM

#### 3.1、JAVA的内存模型

- PC寄存器/程序计数器
- Java栈 Java Stack
- 堆Heap
- 方法区Method Area
- 常量池Constant Pool
- 本地方法栈Native Method Stack
- Java的内存模型围绕着并发编程中的原子性（Atomicity）、可见性（Visibility）、有序性。

#### 3.2、JVM的调优参数

##### 堆设置

##### 收集器设置

##### 垃圾回收统计信息

##### 并行收集器设置

##### 并发收集器设置

#### 3.3、GC的算法原理

#### 3.3、Volatile关键字的作用

具有可见性、有序性、不具备原子性

不会让线程阻塞，响应速度比synchronized高

### 4.网络

#### 4.1、RPC和HTTP的区别

- 速度来看，RPC要比http更快，虽然底层都是TCP，但是http协议的信息往往比较臃肿，不过采用gzip压缩。
- 难度来看，RPC实现较为复杂，http相对比较简单
- 灵活性来看，http更胜一筹，因为它不关心实现细节，跨平台、跨语言

##### 因此，两者都有不同的使用场景：

- 如果对效率要求更高，并且开发过程使用统一的技术栈，那么用RPC还是不错的
- 如果需要更加灵活，跨语言、跨平台，显然http更合适

微服务，更加强调的是独立、自治、灵活。而RPC方式的限制较多，因此微服务框架中，一般都会采用基于Http的Rest风格服务，像在公司对内系统用hsf协议，对接外部系统用微服务，调用RestTemplate这个类

#### 4.2、RPC原理，流程

#### 4.3、HTTP原理、流程

#### 4.3、BIO和NIO、AIO

### 5.数据库

#### 5.1、SQL优化

#### 5.2、mysql调优

#### 5.3、数据库引擎的特点和场景

#### 5.4、mysql的分片和读写分离

#### 5.5、mysql的事务

#### 5.5、mysql引擎

##### 1、常用的数据库引擎（Innodb、MyIASM）

a.Innodb引擎，Innodb引擎提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。它本身实际上是基于Mysql后台的完整的系统。Mysql运行的时候，Innodb会在内存中建立缓冲池，用于缓冲数据和索引。但是，该引擎是不支持全文搜索的。同时，启动也比较的慢，它是不会保存表的行数的。当进行Select count(*) from table指令的时候，需要进行扫描全表。所以当需要使用数据库的事务时，该引擎就是首选。由于锁的粒度小，写操作是不会锁定全表的。所以在并发度较高的场景下使用会提升效率的。

b.MyIASM引擎，它是MySql的默认引擎，但不提供事务的支持，也不支持行级锁和外键。因此当执行Insert插入和Update更新语句时，即执行写操作的时候需要锁定这个表。所以会导致效率会降低。不过和Innodb不同的是，MyIASM引擎是保存了表的行数，于是当进行Select count(*) from table语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的。可以将MyIASM作为数据库引擎的首先。

补充2点：

c.大容量的数据集时趋向于选择Innodb。因为它支持事务处理和故障的恢复。Innodb可以利用数据日志来进行数据的恢复。主键的查询在Innodb也是比较快的。

d.大批量的插入语句时（这里是INSERT语句）在MyIASM引擎中执行的比较的快，但是UPDATE语句在Innodb下执行的会比较的快，尤其是在并发量大的时候。

##### 2、两种引擎所使用的索引的数据结构

B+树

### 6.Redis

#### 6.1、Redis和Memcache的区别

#### 6.2、redis的持久化方案

#### 6.3、redis的分片和主从及哨兵

#### 6.4、如何避免缓存击穿、缓存失效、等问题

#### 6.5、redis实现分布式锁，利用SETNX，不过会出现死锁问题

### 7.消息中间件RabbitMQ、ActiveMQ、Kafka

#### 7.1、为什么使用消息中间件

解决分布式系统中的耦合，异步调用

#### 7.2、如何避免消息丢失

![](C:\Users\wzh\Desktop\Java interview\images\rabbitmq-message-lose-solution.png)

#### 7.3、如何避免消息堆积

先修复 consumer 的问题，确保其恢复消费速度

#### 7.4、如何避免消息重复消费，或者说，如何保证消息的幂等性



#### 7.5、如果让你写一个消息队列，该如何进行架构设计？说一下你的思路

- 首先mq得支持可伸缩性，参照kafka的设计理念
- 其次你得考虑一下这个 mq 的数据要不要落地磁盘吧？那肯定要了
- 其次你考虑一下你的 mq 的可用性啊？这个事儿，具体参考之前可用性那个环节讲解的 kafka 的高可用保障机制。
- 能不能支持数据 0 丢失啊？可以的，参考我们之前说的那个 kafka 数据零丢失方案。

### 8.分布式事务

#### 8.1、什么是事务

保证数据的一致性和完整性。

#### 8.2、什么是分布式事务

就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。本质上来说，分布式事务就是为了保证不同[数据库的数据一致性。

#### 8.3、为什么会产生分布式事务

##### 8.3.1、数据库分库分表

当数据库单表一年产生的数据超过1000W，那么就要考虑分库分表，简单的说就是原来的一个数据库变成了多个数据库。这时候，如果一个操作既访问01库，又访问02库，而且要保证数据的一致性，那么就要用到分布式事务。

![](C:\Users\wzh\Desktop\Java interview\images\20180426090427436.png)

##### 8.3.2、应用SOA化

所谓的SOA化，就是业务的服务化。比如原来单机支撑了整个电商网站，现在对整个网站进行拆解，分离出了订单中心、用户中心、库存中心。对于订单中心，各自都是单独的数据库。那么就会涉及到订单数据库和库存数据库，为了保证数据一致性，就需要用到分布式事务。

![](C:\Users\wzh\Desktop\Java interview\images\20180426090427437.png)





以上两种情况表象不同，但是本质相同，都是因为要操作的数据库变多了！

#### 8.4、事务的ACID特性

##### 8.4.1、原子性（Atomicity）

所谓的原子性就是说，在整个事务中的所有操作，要么全部完成，要么全部不做，没有中间状态。对于事务在执行中发生错误，所有的操作都会被回滚，整个事务就像从没被执行过一样。

##### 8.4.2、一致性（Consistency）

事务的执行必须保证系统的一致性，就拿转账为例，A有500元，B有300元，如果在一个事务里A成功转给B50元，那么不管并发多少，不管发生什么，只要事务执行成功了，那么最后A账户一定是450元，B账户一定是350元。

##### 8.4.3、隔离性（Isolation）

所谓的隔离性就是说，事务与事务之间不会互相影响，一个事务的中间状态不会被其他事务感知。

##### 8.4.4、持久性（Durability）

所谓的持久性，就是说一单事务完成了，那么事务对数据所做的变更就完全保存在了数据库中，即使发生停电，系统宕机也是如此。

#### 8.5、分布式事务的应用场景

8.5.1、支付

最经典的场景就是支付了，一笔支付，是对买家账户进行扣款，同时对卖家账户进行加钱，这些操作必须在一个事务里执行，要么全部成功，要么全部失败。而对于买家账户属于买家中心，对应的是买家数据库，而卖家账户属于卖家中心，对应的是卖家数据库，对不同数据库的操作必然需要引入分布式事务。

8.5.2、在线下单

买家在电商平台下单，往往会涉及到两个动作，一个是扣库存，第二个是更新订单状态，库存和订单一般属于不同的数据库，需要使用分布式事务保证数据一致性。

#### 8.6、常见的分布式事务解决方案

##### 8.6.1、基于XA协议的两阶段提交

**XA是一个分布式事务协议**，由Tuxedo提出。XA中大致分为两部分：事务管理器和本地资源管理器。其中本地资源管理器往往由数据库实现，比如Oracle、DB2这些商业数据库都实现了XA接口，而事务管理器作为全局的调度者，负责各个本地资源的提交和回滚。XA实现分布式事务的原理如下：

![](C:\Users\wzh\Desktop\Java interview\images\20180426090427438.png)

总的来说，XA协议比较简单，而且一旦商业数据库实现了XA协议，使用分布式事务的成本也比较低。但是，XA也有致命的缺点，那就是性能不理想，特别是在交易下单链路，往往并发量很高，XA无法满足高并发场景。XA目前在商业数据库支持的比较理想，在mysql数据库中支持的不太理想，mysql的XA实现，没有记录prepare阶段日志，主备切换回导致主库与备库数据不一致。许多nosql也没有支持XA，这让XA的应用场景变得非常狭隘。

##### 8.6.2、消息事务+最终一致性

所谓的消息事务就是基于消息中间件的两阶段提交，本质上是对消息中间件的一种特殊利用，它是将本地事务和发消息放在了一个分布式事务里，保证要么本地操作成功成功并且对外发消息成功，要么两者都失败，开源的RocketMQ就支持这一特性，具体原理如下：

![](C:\Users\wzh\Desktop\Java interview\images\20180426090427439.png)

1、A系统向消息中间件发送一条预备消息

2、消息中间件保存预备消息并返回成功

3、A执行本地事务

4、A发送提交消息给消息中间件

通过以上4步完成了一个消息事务。对于以上的4个步骤，每个步骤都可能产生错误，下面一一分析：

步骤一出错，则整个事务失败，不会执行A的本地操作 步骤二出错，则整个事务失败，不会执行A的本地操作 步骤三出错，这时候需要回滚预备消息，怎么回滚？答案是A系统实现一个消息中间件的回调接口，消息中间件会去不断执行回调接口，检查A事务执行是否执行成功，如果失败则回滚预备消息 步骤四出错，这时候A的本地事务是成功的，那么消息中间件要回滚A吗？答案是不需要，其实通过回调接口，消息中间件能够检查到A执行成功了，这时候其实不需要A发提交消息了，消息中间件可以自己对消息进行提交，从而完成整个消息事务

基于消息中间件的两阶段提交往往用在高并发场景下，将一个分布式事务拆成一个消息事务（A系统的本地操作+发消息）+B系统的本地操作，其中B系统的操作由消息驱动，只要消息事务成功，那么A操作一定成功，消息也一定发出来了，这时候B会收到消息去执行本地操作，如果本地操作失败，消息会重投，直到B操作成功，这样就变相地实现了A与B的分布式事务。原理如下：

![](C:\Users\wzh\Desktop\Java interview\images\20180426090427440.png)

虽然上面的方案能够完成A和B的操作，但是A和B并不是严格一致的，而是最终一致的，我们在这里牺牲了一致性，换来了性能的大幅度提升。当然，这种玩法也是有风险的，如果B一直执行不成功，那么一致性会被破坏，具体要不要玩，还是得看业务能够承担多少风险。

##### 8.6.3、TCC编程模式

所谓的TCC编程模式，也是两阶段提交的一个变种。TCC提供了一个编程框架，将整个业务逻辑分为三块：Try、Confirm和Cancel三个操作。以在线下单为例，Try阶段会去扣库存，Confirm阶段则是去更新订单状态，如果更新订单失败，则进入Cancel阶段，会去恢复库存。总之，TCC就是通过代码人为实现了两阶段提交，不同的业务场景所写的代码都不一样，复杂度也不一样，因此，这种模式并不能很好地被复用。

##### 8.6.4、总结

分布式事务，本质上是对多个数据库的事务进行统一控制，按照控制力度可以分为：不控制、部分控制和完全控制。不控制就是不引入分布式事务，部分控制就是各种变种的两阶段提交，包括上面提到的消息事务+最终一致性、TCC模式，而完全控制就是完全实现两阶段提交。部分控制的好处是并发量和性能很好，缺点是数据一致性减弱了，完全控制则是牺牲了性能，保障了一致性，具体用哪种方式，最终还是取决于业务场景。作为技术人员，一定不能忘了技术是为业务服务的，不要为了技术而技术，针对不同业务进行技术选型也是一种很重要的能力！

#### 8.3、分布式事务方案，2PC、3PC、TCC补偿性事务、基于可靠消息的最终一致性

### 9.框架原理、源码分析

#### 9.1、Servlet的实现原理

#### 9.2、Spring IOC AOP、SpringMVC的源码、Spring的事务实现方式

##### 5、spring的事务实现方式

- 编程式事务管理对基于 POJO 的应用来说是唯一选择。我们需要在代码中调用beginTransaction()、commit()、rollback()等事务管理相关的方法，这就是编程式事务管理
- 基于 TransactionProxyFactoryBean的声明式事务管理
- 基于 @Transactional 的声明式事务管理
- 基于Aspectj AOP配置事务

#### 9.3、SpringBoot

##### 1.什么是SpringBoot

- 用来简化spring应用的初始搭建以及开发过程 使用特定的方式来进行配置（properties或yml文件） 
- 创建独立的spring引用程序main方法运行
- 嵌入的Tomcat无需部署war文件
- 简化maven配置
- 自动配置spring添加对应功能starter自动化配置

##### 2.SpringBoot常用starter（可拔插式插件）有哪些

- spring-boot-starter-web 嵌入tomcat和web开发需要servlet与jsp支持
-  spring-boot-starter-data-jpa 数据库支持
-  spring-boot-starter-data-redis redis数据库支持
-  spring-boot-starter-data-solr solr支持
-  mybatis-spring-boot-starter 第三方的mybatis集成starter

##### 3.SpringBoot自动配置原理

在spring程序main方法中 添加@SpringBootApplication或者@EnableAutoConfiguration会自动去maven中读取每个starter中的spring.factories文件  该文件里配置了所有需要被创建spring容器中的bean

##### 4.springboot读取配置文件的方式

  springboot默认读取配置文件为application.properties或者是application.yml

##### 5.springboot集成mybatis的过程

- 添加mybatis的starter  maven依赖
- 在mybatis的接口中 添加@Mapper注解
- 在application.yml配置数据源信息

##### 6.springboot如何添加【修改代码】自动重启功能

  添加开发者工具集=====spring-boot-devtools  热部署

#### 9.4、Mybatis的源码分析和Mapper实现原理

### 10.分布式锁

#### 10.1、为什么会产生分布式锁

大多数互联网系统都是分布式部署的，但是当某个资源在多系统之间，具有共享性的时候，为了保证大家访问这个资源数据是一致的，这个时候我们需要用分布式锁来让多客户端互斥的对共享资源进行访问。

#### 10.2、基于数据库乐观锁

#### 10.3、基于redis的分布式锁

#### 10.4、基于zookeeper的分布式锁

### 11.ElasticSearch和Solr

#### 11.1、区别

1、当单纯的对已有数据进行搜索时，Solr更快。
2、当实时建立索引时, Solr会产生io阻塞，查询性能较差, Elasticsearch具有明显的优势。
3、随着数据量的增加，Solr的搜索效率会变得更低，而Elasticsearch却没有明显的变化。
4、Solr的架构不适合实时搜索的应用。
5、Solr 支持更多格式的数据，而 Elasticsearch 仅支持json文件格式
6、Solr 在传统的搜索应用中表现好于 Elasticsearch，但在处理实时搜索应用时效率明显低于 Elasticsearch

#### 11.2、面试



###  12.SOA、分布式系统和微服务，RPC，RMI，Rest，RestFul，Soap，WebService

#### 12.0、什么是SOA

面向服务的架构（SOA）是一个组件模型，它将应用程序的不同功能单元（称为服务）通过这些服务之间定义良好的接口和契约联系起来。接口是采用中立的方式进行定义的，它应该独立于实现服务的硬件平台、操作系统和编程语言（与平台无关，与语言无关，与操作系统无关）。这使得构建在各种各样的系统中的服务可以以一种统一和通用的方式进行交互。

##### 1、SOA最显著的优势：

- SOA具有低耦合性特点，业务伙伴对整个业务系统的影响较低
- SOA与平台无关，减少了业务应用实现的限制

##### 2、SOA与微服务架构的区别：

- 微服务相比于SOA更加精细，微服务更多的以独立的进程的方式存在，互相之间并无影响；
- 微服务提供的接口方式更加通用化，例如HTTP RESTful方式，各种终端都可以调用，无关语言、平台限制；
- 微服务更倾向于分布式去中心化的部署方式，在互联网业务场景下更适合；

#### 12.1、微服务和分布式的区别

- 微服务是架构设计方式，分布式是系统部署方式

- 微服务可以用不同的语言，比如Ruby写的服务可以调用GO写的服务，之间通过Http通信。

#### 12.2、什么是微服务、分布式系统

- 微服务是将传统的一站式应用，拆分成一个个的服务，彻底去耦合，一个微服务就是单功能业务，只做一件事。
- 分布式系统是由一组通过网络进行通信、为了完成共同的任务而协调工作的计算机节点组成的系统。
- 分布式系统的几个特性：**可扩展性、高性能、高可用、一致性**

#### 12.3、WebService是什么

Web service是一个平台独立的，低耦合的，自包含的、基于可编程的web的应用程序，可使用开放的XML（标准通用标记语言下的一个子集）标准来描述、发布、发现、协调和配置这些应用程序，用于开发分布式的互操作的应用程序。

#### 12.4、什么是RPC

#### 12.5、什么是RMI

#### 12.6、什么是Rest

### 13.SpringCloud和Dubbo的区别

是微服务的一站式解决方案，Doubbo只是RPC框架，

|          | SpringCloud | Doubbo | Doubbo2.7 |
| -------- | ----------- | ------ | --------- |
| 通信方式 | http        | rpc    | http+json |
|          |             |        |           |

### 14.SpringCloud组件原理分析

#### 14.1、Netflix Eureka

#### 14.2、Netflix Zuul

#### 14.3、Fegin

#### 14.4、Netflix Ribbon

#### 14.5、Gateway

#### 14.6、Netflix Hystrix

#### 14.7、Sleuth Zipkin

#### 14.8、Config

#### 14.9、Bus

### 15.SpringCloud 和 Netflix之间的关系

#### 15.1、SpringCloud

- Zookeeper/Consul/Etcd     注册中心 第三方
- Config      配置中心
- Geteway   网关
- Bus        服务总线，刷新配置文件
- Stream           消息驱动
- OpenFeign      基于Feign的升级  服务之间调用
- Loadbalancer   负载均衡
- Resilience4J    熔断器
- Sleuth Zipkin  链路追踪

#### 15.2、Netflix

- Eureka       注册中心
- Zuul            网关
- Ribbon       负载均衡
- Hystrix       熔断器

### 16.Alibaba Dubbo的分析

#### 16.1、Dubbo的原理

#### 16.2、Netty的原理

### 17.Java设计模式

#### 17.1、策略模式

#### 17.2、工厂模式

#### 17.3、模板方法

#### 17.4、代理模式

#### 17.5、责任链

#### 17.6、单例模式

#### 17.7、适配器/外观

#### 17.8、观察者模式

### 18.Zookeeper

### 19.CI（持续集成）/CD（持续交付），敏捷开发

#### 19.1、持续化部署

**持续集成**(Continuous integration)    CI：代码合并、构建、部署、测试都在一起，不断地执行这个过程

**持续部署**（Continuous deployment）CD：部署到测试环境、预生成环境、生成环境

**持续交付**（Continuous delivery）CD：将最终的产品发布生产环境

**持续集成工具如下：**

Jenkins

GitLab CI

**持续化部署方案：**

Docker：

Jenkins：

Kubernetes（k8s）：从git拉去代码，Jenkins和maven的配置，生成一个pod，容器编排，docker容器化部署

**Jenkins和Kubernetes搭建CI/CD流水线有诸多好处**

- Jenkins高可用
- 自动伸缩
- 环境隔离
- 易维护

### 20.电商行业的技术特点

- 技术范围广
- 技术新
- 高并发（分布式、静态化技术、缓存技术、异步并发（异步下订单）、池化、队列）
- 高可用（集群、负载均衡、限流（网关实现）、降级（其他的服务关停）、熔断）
- 数据量大（数据库分库分表，大数据处理Hadoop，Spark）
- 业务复杂
- 数据安全

### 21.安全处理技术

#### 1.加密解密

#### 2.签名验签

### 22.前端技术

#### 1.angular

#### 2.react

#### 3.vue

### 面试介绍（技术栈+项目核心）(2019年5月)

#### 1.支付系统

#### 2.搜索系统

#### 3.授权系统（JWT）

#### 4.VUE









